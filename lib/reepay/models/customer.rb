=begin
#API

#REST API to manage Reepay resources

OpenAPI spec version: 1

Generated by: https://github.com/swagger-api/swagger-codegen.git
Swagger Codegen version: 2.3.1

=end

require 'date'

module Reepay

  class Customer
    # Customer email
    attr_accessor :email

    # Customer address
    attr_accessor :address

    # Customer address2
    attr_accessor :address2

    # Customer city
    attr_accessor :city

    # Customer country in ISO 3166-1 alpha-2
    attr_accessor :country

    # Customer phone number
    attr_accessor :phone

    # Customer company
    attr_accessor :company

    # Customer vat number
    attr_accessor :vat

    # Per account unique handle for the customer. Max length 255 with allowable characters [a-zA-Z0-9_.-@].
    attr_accessor :handle

    # Test flag
    attr_accessor :test

    # Number of active subscriptions for this customer (deprecated, will be removed in a later version, use active_subscriptions)
    attr_accessor :subscriptions

    # Date when the customer was created. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
    attr_accessor :created

    # Date when the customer was deleted. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
    attr_accessor :deleted

    # Customer first name
    attr_accessor :first_name

    # Customer last name
    attr_accessor :last_name

    # Customer postal code
    attr_accessor :postal_code

    # Number of active subscriptions for this customer
    attr_accessor :active_subscriptions

    # Number of active subscriptions in trial for this customer
    attr_accessor :trial_active_subscriptions

    # Number of cancelled subscriptions in trial for this customer
    attr_accessor :trial_cancelled_subscriptions

    # Number of expired subscription for this customer
    attr_accessor :expired_subscriptions

    # Number of subscription on hold for this customer
    attr_accessor :on_hold_subscriptions

    # Number of cancelled subscription for this customer
    attr_accessor :cancelled_subscriptions

    # Number of non renewing (active subscriptions not renewing at billing period end) subscriptions for this customer
    attr_accessor :non_renewing_subscriptions

    # Number of failed subscription invoices for this customer
    attr_accessor :failed_invoices

    # Summed amount for failed subscription invoices
    attr_accessor :failed_amount

    # Number of cancelled subscription invoices for this customer
    attr_accessor :cancelled_invoices

    # Summed amount for cancelled subscription invoices
    attr_accessor :cancelled_amount

    # Number of pending subscription invoices for this customer
    attr_accessor :pending_invoices

    # Summed amount for pending subscription invoices
    attr_accessor :pending_amount

    # Number of dunning subscription invoices for this customer
    attr_accessor :dunning_invoices

    # Summed amount for dunning subscription invoices
    attr_accessor :dunning_amount

    # Number of settled subscription invoices for this customer
    attr_accessor :settled_invoices

    # Summed settled subscription amount
    attr_accessor :settled_amount

    # Summed refunded subscription amount
    attr_accessor :refunded_amount

    # Number of pending additional costs
    attr_accessor :pending_additional_costs

    # Summed amount of pending additional costs incl vat
    attr_accessor :pending_additional_cost_amount

    # Number of additional costs that have been applied to invoices
    attr_accessor :transferred_additional_costs

    # Summed amount of additional costs that have been applied to invoices
    attr_accessor :transferred_additional_cost_amount

    # Number of credits that have not fully been applied to invoices
    attr_accessor :pending_credits

    # Summed credit amount not yet applied to invoices
    attr_accessor :pending_credit_amount

    # Number of credits that have fully been applied to invoices
    attr_accessor :transferred_credits

    # Summed credit amount that have been applied to invoices
    attr_accessor :transferred_credit_amount


    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        :'email' => :'email',
        :'address' => :'address',
        :'address2' => :'address2',
        :'city' => :'city',
        :'country' => :'country',
        :'phone' => :'phone',
        :'company' => :'company',
        :'vat' => :'vat',
        :'handle' => :'handle',
        :'test' => :'test',
        :'subscriptions' => :'subscriptions',
        :'created' => :'created',
        :'deleted' => :'deleted',
        :'first_name' => :'first_name',
        :'last_name' => :'last_name',
        :'postal_code' => :'postal_code',
        :'active_subscriptions' => :'active_subscriptions',
        :'trial_active_subscriptions' => :'trial_active_subscriptions',
        :'trial_cancelled_subscriptions' => :'trial_cancelled_subscriptions',
        :'expired_subscriptions' => :'expired_subscriptions',
        :'on_hold_subscriptions' => :'on_hold_subscriptions',
        :'cancelled_subscriptions' => :'cancelled_subscriptions',
        :'non_renewing_subscriptions' => :'non_renewing_subscriptions',
        :'failed_invoices' => :'failed_invoices',
        :'failed_amount' => :'failed_amount',
        :'cancelled_invoices' => :'cancelled_invoices',
        :'cancelled_amount' => :'cancelled_amount',
        :'pending_invoices' => :'pending_invoices',
        :'pending_amount' => :'pending_amount',
        :'dunning_invoices' => :'dunning_invoices',
        :'dunning_amount' => :'dunning_amount',
        :'settled_invoices' => :'settled_invoices',
        :'settled_amount' => :'settled_amount',
        :'refunded_amount' => :'refunded_amount',
        :'pending_additional_costs' => :'pending_additional_costs',
        :'pending_additional_cost_amount' => :'pending_additional_cost_amount',
        :'transferred_additional_costs' => :'transferred_additional_costs',
        :'transferred_additional_cost_amount' => :'transferred_additional_cost_amount',
        :'pending_credits' => :'pending_credits',
        :'pending_credit_amount' => :'pending_credit_amount',
        :'transferred_credits' => :'transferred_credits',
        :'transferred_credit_amount' => :'transferred_credit_amount'
      }
    end

    # Attribute type mapping.
    def self.swagger_types
      {
        :'email' => :'String',
        :'address' => :'String',
        :'address2' => :'String',
        :'city' => :'String',
        :'country' => :'String',
        :'phone' => :'String',
        :'company' => :'String',
        :'vat' => :'String',
        :'handle' => :'String',
        :'test' => :'BOOLEAN',
        :'subscriptions' => :'Integer',
        :'created' => :'DateTime',
        :'deleted' => :'DateTime',
        :'first_name' => :'String',
        :'last_name' => :'String',
        :'postal_code' => :'String',
        :'active_subscriptions' => :'Integer',
        :'trial_active_subscriptions' => :'Integer',
        :'trial_cancelled_subscriptions' => :'Integer',
        :'expired_subscriptions' => :'Integer',
        :'on_hold_subscriptions' => :'Integer',
        :'cancelled_subscriptions' => :'Integer',
        :'non_renewing_subscriptions' => :'Integer',
        :'failed_invoices' => :'Integer',
        :'failed_amount' => :'Integer',
        :'cancelled_invoices' => :'Integer',
        :'cancelled_amount' => :'Integer',
        :'pending_invoices' => :'Integer',
        :'pending_amount' => :'Integer',
        :'dunning_invoices' => :'Integer',
        :'dunning_amount' => :'Integer',
        :'settled_invoices' => :'Integer',
        :'settled_amount' => :'Integer',
        :'refunded_amount' => :'Integer',
        :'pending_additional_costs' => :'Integer',
        :'pending_additional_cost_amount' => :'Integer',
        :'transferred_additional_costs' => :'Integer',
        :'transferred_additional_cost_amount' => :'Integer',
        :'pending_credits' => :'Integer',
        :'pending_credit_amount' => :'Integer',
        :'transferred_credits' => :'Integer',
        :'transferred_credit_amount' => :'Integer'
      }
    end

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(attributes = {})
      return unless attributes.is_a?(Hash)

      # convert string to symbol for hash key
      attributes = attributes.each_with_object({}){|(k,v), h| h[k.to_sym] = v}

      if attributes.has_key?(:'email')
        self.email = attributes[:'email']
      end

      if attributes.has_key?(:'address')
        self.address = attributes[:'address']
      end

      if attributes.has_key?(:'address2')
        self.address2 = attributes[:'address2']
      end

      if attributes.has_key?(:'city')
        self.city = attributes[:'city']
      end

      if attributes.has_key?(:'country')
        self.country = attributes[:'country']
      end

      if attributes.has_key?(:'phone')
        self.phone = attributes[:'phone']
      end

      if attributes.has_key?(:'company')
        self.company = attributes[:'company']
      end

      if attributes.has_key?(:'vat')
        self.vat = attributes[:'vat']
      end

      if attributes.has_key?(:'handle')
        self.handle = attributes[:'handle']
      end

      if attributes.has_key?(:'test')
        self.test = attributes[:'test']
      end

      if attributes.has_key?(:'subscriptions')
        self.subscriptions = attributes[:'subscriptions']
      end

      if attributes.has_key?(:'created')
        self.created = attributes[:'created']
      end

      if attributes.has_key?(:'deleted')
        self.deleted = attributes[:'deleted']
      end

      if attributes.has_key?(:'first_name')
        self.first_name = attributes[:'first_name']
      end

      if attributes.has_key?(:'last_name')
        self.last_name = attributes[:'last_name']
      end

      if attributes.has_key?(:'postal_code')
        self.postal_code = attributes[:'postal_code']
      end

      if attributes.has_key?(:'active_subscriptions')
        self.active_subscriptions = attributes[:'active_subscriptions']
      end

      if attributes.has_key?(:'trial_active_subscriptions')
        self.trial_active_subscriptions = attributes[:'trial_active_subscriptions']
      end

      if attributes.has_key?(:'trial_cancelled_subscriptions')
        self.trial_cancelled_subscriptions = attributes[:'trial_cancelled_subscriptions']
      end

      if attributes.has_key?(:'expired_subscriptions')
        self.expired_subscriptions = attributes[:'expired_subscriptions']
      end

      if attributes.has_key?(:'on_hold_subscriptions')
        self.on_hold_subscriptions = attributes[:'on_hold_subscriptions']
      end

      if attributes.has_key?(:'cancelled_subscriptions')
        self.cancelled_subscriptions = attributes[:'cancelled_subscriptions']
      end

      if attributes.has_key?(:'non_renewing_subscriptions')
        self.non_renewing_subscriptions = attributes[:'non_renewing_subscriptions']
      end

      if attributes.has_key?(:'failed_invoices')
        self.failed_invoices = attributes[:'failed_invoices']
      end

      if attributes.has_key?(:'failed_amount')
        self.failed_amount = attributes[:'failed_amount']
      end

      if attributes.has_key?(:'cancelled_invoices')
        self.cancelled_invoices = attributes[:'cancelled_invoices']
      end

      if attributes.has_key?(:'cancelled_amount')
        self.cancelled_amount = attributes[:'cancelled_amount']
      end

      if attributes.has_key?(:'pending_invoices')
        self.pending_invoices = attributes[:'pending_invoices']
      end

      if attributes.has_key?(:'pending_amount')
        self.pending_amount = attributes[:'pending_amount']
      end

      if attributes.has_key?(:'dunning_invoices')
        self.dunning_invoices = attributes[:'dunning_invoices']
      end

      if attributes.has_key?(:'dunning_amount')
        self.dunning_amount = attributes[:'dunning_amount']
      end

      if attributes.has_key?(:'settled_invoices')
        self.settled_invoices = attributes[:'settled_invoices']
      end

      if attributes.has_key?(:'settled_amount')
        self.settled_amount = attributes[:'settled_amount']
      end

      if attributes.has_key?(:'refunded_amount')
        self.refunded_amount = attributes[:'refunded_amount']
      end

      if attributes.has_key?(:'pending_additional_costs')
        self.pending_additional_costs = attributes[:'pending_additional_costs']
      end

      if attributes.has_key?(:'pending_additional_cost_amount')
        self.pending_additional_cost_amount = attributes[:'pending_additional_cost_amount']
      end

      if attributes.has_key?(:'transferred_additional_costs')
        self.transferred_additional_costs = attributes[:'transferred_additional_costs']
      end

      if attributes.has_key?(:'transferred_additional_cost_amount')
        self.transferred_additional_cost_amount = attributes[:'transferred_additional_cost_amount']
      end

      if attributes.has_key?(:'pending_credits')
        self.pending_credits = attributes[:'pending_credits']
      end

      if attributes.has_key?(:'pending_credit_amount')
        self.pending_credit_amount = attributes[:'pending_credit_amount']
      end

      if attributes.has_key?(:'transferred_credits')
        self.transferred_credits = attributes[:'transferred_credits']
      end

      if attributes.has_key?(:'transferred_credit_amount')
        self.transferred_credit_amount = attributes[:'transferred_credit_amount']
      end

    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properties with the reasons
    def list_invalid_properties
      invalid_properties = Array.new
      if @handle.nil?
        invalid_properties.push("invalid value for 'handle', handle cannot be nil.")
      end

      if @subscriptions.nil?
        invalid_properties.push("invalid value for 'subscriptions', subscriptions cannot be nil.")
      end

      if @created.nil?
        invalid_properties.push("invalid value for 'created', created cannot be nil.")
      end

      if @active_subscriptions.nil?
        invalid_properties.push("invalid value for 'active_subscriptions', active_subscriptions cannot be nil.")
      end

      if @trial_active_subscriptions.nil?
        invalid_properties.push("invalid value for 'trial_active_subscriptions', trial_active_subscriptions cannot be nil.")
      end

      if @trial_cancelled_subscriptions.nil?
        invalid_properties.push("invalid value for 'trial_cancelled_subscriptions', trial_cancelled_subscriptions cannot be nil.")
      end

      if @expired_subscriptions.nil?
        invalid_properties.push("invalid value for 'expired_subscriptions', expired_subscriptions cannot be nil.")
      end

      if @on_hold_subscriptions.nil?
        invalid_properties.push("invalid value for 'on_hold_subscriptions', on_hold_subscriptions cannot be nil.")
      end

      if @cancelled_subscriptions.nil?
        invalid_properties.push("invalid value for 'cancelled_subscriptions', cancelled_subscriptions cannot be nil.")
      end

      if @non_renewing_subscriptions.nil?
        invalid_properties.push("invalid value for 'non_renewing_subscriptions', non_renewing_subscriptions cannot be nil.")
      end

      if @failed_invoices.nil?
        invalid_properties.push("invalid value for 'failed_invoices', failed_invoices cannot be nil.")
      end

      if @failed_amount.nil?
        invalid_properties.push("invalid value for 'failed_amount', failed_amount cannot be nil.")
      end

      if @cancelled_invoices.nil?
        invalid_properties.push("invalid value for 'cancelled_invoices', cancelled_invoices cannot be nil.")
      end

      if @cancelled_amount.nil?
        invalid_properties.push("invalid value for 'cancelled_amount', cancelled_amount cannot be nil.")
      end

      if @pending_invoices.nil?
        invalid_properties.push("invalid value for 'pending_invoices', pending_invoices cannot be nil.")
      end

      if @pending_amount.nil?
        invalid_properties.push("invalid value for 'pending_amount', pending_amount cannot be nil.")
      end

      if @dunning_invoices.nil?
        invalid_properties.push("invalid value for 'dunning_invoices', dunning_invoices cannot be nil.")
      end

      if @dunning_amount.nil?
        invalid_properties.push("invalid value for 'dunning_amount', dunning_amount cannot be nil.")
      end

      if @settled_invoices.nil?
        invalid_properties.push("invalid value for 'settled_invoices', settled_invoices cannot be nil.")
      end

      if @settled_amount.nil?
        invalid_properties.push("invalid value for 'settled_amount', settled_amount cannot be nil.")
      end

      if @refunded_amount.nil?
        invalid_properties.push("invalid value for 'refunded_amount', refunded_amount cannot be nil.")
      end

      if @pending_additional_costs.nil?
        invalid_properties.push("invalid value for 'pending_additional_costs', pending_additional_costs cannot be nil.")
      end

      if @pending_additional_cost_amount.nil?
        invalid_properties.push("invalid value for 'pending_additional_cost_amount', pending_additional_cost_amount cannot be nil.")
      end

      if @transferred_additional_costs.nil?
        invalid_properties.push("invalid value for 'transferred_additional_costs', transferred_additional_costs cannot be nil.")
      end

      if @transferred_additional_cost_amount.nil?
        invalid_properties.push("invalid value for 'transferred_additional_cost_amount', transferred_additional_cost_amount cannot be nil.")
      end

      if @pending_credits.nil?
        invalid_properties.push("invalid value for 'pending_credits', pending_credits cannot be nil.")
      end

      if @pending_credit_amount.nil?
        invalid_properties.push("invalid value for 'pending_credit_amount', pending_credit_amount cannot be nil.")
      end

      if @transferred_credits.nil?
        invalid_properties.push("invalid value for 'transferred_credits', transferred_credits cannot be nil.")
      end

      if @transferred_credit_amount.nil?
        invalid_properties.push("invalid value for 'transferred_credit_amount', transferred_credit_amount cannot be nil.")
      end

      return invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      return false if @handle.nil?
      return false if @subscriptions.nil?
      return false if @created.nil?
      return false if @active_subscriptions.nil?
      return false if @trial_active_subscriptions.nil?
      return false if @trial_cancelled_subscriptions.nil?
      return false if @expired_subscriptions.nil?
      return false if @on_hold_subscriptions.nil?
      return false if @cancelled_subscriptions.nil?
      return false if @non_renewing_subscriptions.nil?
      return false if @failed_invoices.nil?
      return false if @failed_amount.nil?
      return false if @cancelled_invoices.nil?
      return false if @cancelled_amount.nil?
      return false if @pending_invoices.nil?
      return false if @pending_amount.nil?
      return false if @dunning_invoices.nil?
      return false if @dunning_amount.nil?
      return false if @settled_invoices.nil?
      return false if @settled_amount.nil?
      return false if @refunded_amount.nil?
      return false if @pending_additional_costs.nil?
      return false if @pending_additional_cost_amount.nil?
      return false if @transferred_additional_costs.nil?
      return false if @transferred_additional_cost_amount.nil?
      return false if @pending_credits.nil?
      return false if @pending_credit_amount.nil?
      return false if @transferred_credits.nil?
      return false if @transferred_credit_amount.nil?
      return true
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(o)
      return true if self.equal?(o)
      self.class == o.class &&
          email == o.email &&
          address == o.address &&
          address2 == o.address2 &&
          city == o.city &&
          country == o.country &&
          phone == o.phone &&
          company == o.company &&
          vat == o.vat &&
          handle == o.handle &&
          test == o.test &&
          subscriptions == o.subscriptions &&
          created == o.created &&
          deleted == o.deleted &&
          first_name == o.first_name &&
          last_name == o.last_name &&
          postal_code == o.postal_code &&
          active_subscriptions == o.active_subscriptions &&
          trial_active_subscriptions == o.trial_active_subscriptions &&
          trial_cancelled_subscriptions == o.trial_cancelled_subscriptions &&
          expired_subscriptions == o.expired_subscriptions &&
          on_hold_subscriptions == o.on_hold_subscriptions &&
          cancelled_subscriptions == o.cancelled_subscriptions &&
          non_renewing_subscriptions == o.non_renewing_subscriptions &&
          failed_invoices == o.failed_invoices &&
          failed_amount == o.failed_amount &&
          cancelled_invoices == o.cancelled_invoices &&
          cancelled_amount == o.cancelled_amount &&
          pending_invoices == o.pending_invoices &&
          pending_amount == o.pending_amount &&
          dunning_invoices == o.dunning_invoices &&
          dunning_amount == o.dunning_amount &&
          settled_invoices == o.settled_invoices &&
          settled_amount == o.settled_amount &&
          refunded_amount == o.refunded_amount &&
          pending_additional_costs == o.pending_additional_costs &&
          pending_additional_cost_amount == o.pending_additional_cost_amount &&
          transferred_additional_costs == o.transferred_additional_costs &&
          transferred_additional_cost_amount == o.transferred_additional_cost_amount &&
          pending_credits == o.pending_credits &&
          pending_credit_amount == o.pending_credit_amount &&
          transferred_credits == o.transferred_credits &&
          transferred_credit_amount == o.transferred_credit_amount
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(o)
      self == o
    end

    # Calculates hash code according to all attributes.
    # @return [Fixnum] Hash code
    def hash
      [email, address, address2, city, country, phone, company, vat, handle, test, subscriptions, created, deleted, first_name, last_name, postal_code, active_subscriptions, trial_active_subscriptions, trial_cancelled_subscriptions, expired_subscriptions, on_hold_subscriptions, cancelled_subscriptions, non_renewing_subscriptions, failed_invoices, failed_amount, cancelled_invoices, cancelled_amount, pending_invoices, pending_amount, dunning_invoices, dunning_amount, settled_invoices, settled_amount, refunded_amount, pending_additional_costs, pending_additional_cost_amount, transferred_additional_costs, transferred_additional_cost_amount, pending_credits, pending_credit_amount, transferred_credits, transferred_credit_amount].hash
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)
      self.class.swagger_types.each_pair do |key, type|
        if type =~ /\AArray<(.*)>/i
          # check to ensure the input is an array given that the the attribute
          # is documented as an array but the input is not
          if attributes[self.class.attribute_map[key]].is_a?(Array)
            self.send("#{key}=", attributes[self.class.attribute_map[key]].map{ |v| _deserialize($1, v) } )
          end
        elsif !attributes[self.class.attribute_map[key]].nil?
          self.send("#{key}=", _deserialize(type, attributes[self.class.attribute_map[key]]))
        end # or else data not found in attributes(hash), not an issue as the data can be optional
      end

      self
    end

    # Deserializes the data based on type
    # @param string type Data type
    # @param string value Value to be deserialized
    # @return [Object] Deserialized data
    def _deserialize(type, value)
      case type.to_sym
      when :DateTime
        DateTime.parse(value)
      when :Date
        Date.parse(value)
      when :String
        value.to_s
      when :Integer
        value.to_i
      when :Float
        value.to_f
      when :BOOLEAN
        if value.to_s =~ /\A(true|t|yes|y|1)\z/i
          true
        else
          false
        end
      when :Object
        # generic object (usually a Hash), return directly
        value
      when /\AArray<(?<inner_type>.+)>\z/
        inner_type = Regexp.last_match[:inner_type]
        value.map { |v| _deserialize(inner_type, v) }
      when /\AHash<(?<k_type>.+?), (?<v_type>.+)>\z/
        k_type = Regexp.last_match[:k_type]
        v_type = Regexp.last_match[:v_type]
        {}.tap do |hash|
          value.each do |k, v|
            hash[_deserialize(k_type, k)] = _deserialize(v_type, v)
          end
        end
      else # model
        temp_model = Reepay.const_get(type).new
        temp_model.build_from_hash(value)
      end
    end

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # to_body is an alias to to_hash (backward compatibility)
    # @return [Hash] Returns the object in the form of hash
    def to_body
      to_hash
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = self.send(attr)
        next if value.nil?
        hash[param] = _to_hash(value)
      end
      hash
    end

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map{ |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end

  end

end
